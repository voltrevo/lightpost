'use strict';

exports.interpreter = function()
{
    var self = this;
    
    this.builtin_functions =
    {
        '+':
        {
            argc: 2,
            exec: function(a, b) { return a + b; }
        },
        '-':
        {
            argc: 2,
            exec: function(a, b) { return a - b; }
        },
        '*':
        {
            argc: 2,
            exec: function(a, b) { return a * b; }
        },
        '/':
        {
            argc: 2,
            exec: function(a, b) { return a / b; }
        },
        '%':
        {
            argc: 2,
            exec: function(a, b) { return a % b; }
        },
        '**':
        {
            argc: 2,
            exec: function(a, b) { return Math.pow(a, b); }
        },
        '<':
        {
            argc: 2,
            exec: function(a, b) { return a < b; }
        },
        '>':
        {
            argc: 2,
            exec: function(a, b) { return a > b; }
        },
        '<=':
        {
            argc: 2,
            exec: function(a, b) { return a <= b; }
        },
        '>=':
        {
            argc: 2,
            exec: function(a, b) { return a >= b; }
        },
        '==':
        {
            argc: 2,
            exec: function(a, b) { return a == b; }
        },
        '!=':
        {
            argc: 2,
            exec: function(a, b) { return a != b; }
        },
        'print':
        {
            argc: 1,
            exec: function(s) { console.log(s); }
        },
        'inspect':
        {
            argc: 0,
            exec: function()
            {
                process.stdout.write('Stack: ');
                console.log(self.exec_layer.stack);
                
                process.stdout.write('Variables: ');
                console.log(self.variables);
            }
        },
        'exec':
        {
            argc: 1,
            exec: function(fn)
            {
                if (typeof fn !== 'object')
                {
                    console.error('Error: exec: argument is not a function');
                    return;
                }
                
                if (fn.type === 'variable')
                {
                    var value = self.variables[fn.name];

                    if (typeof value !== 'object')
                    {
                        console.error('Error: exec: variable argument is not a function');
                        return;
                    }
                    
                    self.exec_layer.exec(value);
                }
                else if (fn.type === 'function')
                {
                    self.exec_layer.exec(fn.value);
                }
                else
                {
                    throw new Error('Unrecognised type ' + fn.type);
                }
            }
        },
        '=':
        {
            argc: 0,
            exec: function()
            {
                // Check the stack can provide the arguments required
                if (self.exec_layer.stack.length < 2)
                {
                    console.error('Error: Not enough arguments for assignment');
                    self.exec_layer.stack.length = 0;
                    return;
                }
                
                var args = self.exec_layer.stack.splice(self.exec_layer.stack.length - 2, 2);
                
                if (typeof args[0] !== 'object' || args[0].type !== 'variable')
                {
                    console.error('Error: First argument to assignment is not a variable');
                    return;
                }
                
                if (typeof args[1] === 'object')
                {
                    if (args[1].type === 'variable')
                    {
                        var value = self.variables[args[1].name];
                        
                        if (value === undefined)
                        {
                            console.error('Error: Cannot assign ' + args[0].name + ' to undefined variable ' + args[1].name);
                            return;
                        }
                        
                        args[1] = value;
                    }
                    else if (args[1].type === 'function')
                    {
                        args[1] = args[1].value;
                    }
                    else
                    {
                        throw new Error('Unrecognised type ' + args[1].type);
                    }
                }
                
                self.variables[args[0].name] = args[1];
            }
        }
    };
    
    this.variables = {};
    
    this.handle_string = function(str)
    {
        for (var i = 0; i != str.length; i++)
        {
            self.comment_layer.handle_char(str[i]);
        }
    }
    
    this.comment_layer = new (function()
    {
        var layer = this;
        
        this.next_layer = null;
        
        this.had_slash = false;
        this.had_star = false;
        this.had_escape = false;
        
        this.block_depth = 0;
        this.block_has_newline = false;

        this.handle_char = function(c)
        {
            //console.log('comment layer: \'' + c + '\'');
            layer.mode(c);
        }
        
        this.normal_mode = function(c)
        {
            if (c === '"')
            {
                layer.had_slash = false;
                layer.mode = layer.string_mode;
                layer.next_layer.handle_char(c);
            }
            else if (layer.had_slash)
            {
                layer.had_slash = false;
                
                if (c === '/')
                {
                    layer.mode = layer.line_comment_mode;
                }
                else if (c === '*')
                {
                    layer.block_depth = 1;
                    layer.mode = layer.block_comment_mode;
                }
                else
                {
                    layer.next_layer.handle_char('/');
                    layer.next_layer.handle_char(c);
                }
            }
            else
            {
                if (c === '/')
                {
                    layer.had_slash = true;
                }
                else
                {
                    layer.next_layer.handle_char(c);
                }
            }
        }

        this.string_mode = function(c)
        {
            if (layer.had_escape)
            {
                layer.had_escape = false;
            }
            else if (c === '\\')
            {
                layer.had_escape = true;
            }
            else if (c === '"')
            {
                layer.mode = layer.normal_mode;
            }
            
            layer.next_layer.handle_char(c);
        }
        
        this.line_comment_mode = function(c)
        {
            if (c === '\n')
            {
                layer.mode = layer.normal_mode;
                layer.next_layer.handle_char('\n');
            }
        }

        this.block_comment_mode = function(c)
        {
            if (layer.had_slash)
            {
                layer.had_slash = false;
                
                if (c === '*')
                {
                    layer.block_depth++;
                    //console.log('incremented block depth to ' + layer.block_depth);
                }
                else if (c === '\n')
                {
                    layer.block_has_newline = true;
                }
            }
            else if (layer.had_star)
            {
                layer.had_star = false;

                if (c === '/')
                {
                    layer.block_depth--;
                    //console.log('decremented block depth to ' + layer.block_depth);

                    if (layer.block_depth === 0)
                    {
                        layer.next_layer.handle_char(layer.block_has_newline ? '\n' : ' ');
                        layer.block_has_newline = false;
                        layer.mode = layer.normal_mode;
                    }
                }
                else if (c === '\n')
                {
                    layer.block_has_newline = true;
                }
            }
            else
            {
                if (c === '/')
                {
                    layer.had_slash = true;
                }
                else if (c === '*')
                {
                    layer.had_star = true;
                }
            }
        }
        
        this.mode = this.normal_mode;
    })();
    
    this.word_layer = new (function()
    {
        var layer = this;

        this.next_layer = null;
        
        this.word = '';

        this.had_escape = false;
        
        this.handle_char = function(c)
        {
            //console.log('word layer: \'' + c + '\'');
            if (layer.word.length > 0 && layer.word[0] === '"')
            {
                if (layer.had_escape)
                {
                    layer.had_escape = false;
                    layer.word += c;
                }
                else
                {
                    if (c === '\\')
                    {
                        layer.had_escape = true;
                    }
                    else
                    {
                        layer.word += c;
                        
                        if (c === '"')
                        {
                            layer.next_layer.handle_word(layer.word);
                            layer.word = ''; // TODO: this will allow the next word to start without whitespace, e.g. "foo"7 will be two words
                        }
                    }
                }
            }
            else
            {
                if (c === ' ' || c === '\n' || c === '\t' || c === '\r')
                {
                    if (layer.word !== '')
                    {
                        layer.next_layer.handle_word(layer.word);
                        layer.word = '';
                    }
                }
                else
                {
                    layer.word += c;
                }
            }
        }
    })();
    
    this.comment_layer.next_layer = this.word_layer;

    this.number_regex = new RegExp('^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$');
    this.variable_regex = new RegExp('^[a-zA-Z_][a-zA-Z0-9_]*$');
    
    this.exec_layer = new (function()
    {
        var layer = this;
        
        layer.stack = [];
        
        this.handle_word = function(word)
        {
            if (word[word.length - 1] === '#')
            {
                var sub_word = word.substr(0, word.length - 1);

                if (self.builtin_functions[sub_word])
                {
                    layer.stack.push({type: 'function', value: self.builtin_functions[sub_word]});
                }
                else if (self.variables[sub_word])
                {
                    layer.stack.push({type: 'variable', name: sub_word});
                }
                else
                {
                    console.error('Error: No matching symbol for "' + sub_word + '"');
                }
            }
            else if (self.builtin_functions[word])
            {
                layer.exec(self.builtin_functions[word]);
            }
            else if (self.variables[word])
            {
                var variable = self.variables[word];

                if (typeof variable === 'object')
                {
                    layer.exec(variable);
                }
                else
                {
                    layer.stack.push({type: 'variable', name: word});
                }
            }
            else if (self.number_regex.test(word))
            {
                layer.stack.push(parseFloat(word));
            }
            else if (word.length >= 2 && word[0] === '"' && word[word.length - 1] === '"')
            {
                layer.stack.push(word.substr(1, word.length - 2));
            }
            else if (self.variable_regex.test(word))
            {
                layer.stack.push({type: 'variable', name: word});
            }
            else
            {
                console.error('Error: Cannot parse word "' + word + '"');
            }
        }
        
        this.exec = function(fn)
        {
            // Check the stack can provide the arguments required
            if (layer.stack.length < fn.argc)
            {
                console.error('Error: Not enough arguments for function');
                layer.stack.length = 0;
                return;
            }
            
            // Retrieve function arguments from the stack
            var args = layer.stack.splice(layer.stack.length - fn.argc, fn.argc);
            
            // Replace variables with values
            for (var i in args)
            {
                if (typeof args[i] === 'object' && args[i].type === 'variable')
                {
                    var value = self.variables[args[i].name];
                    
                    if (value === undefined)
                    {
                        console.error('Error: Cannot call function with undefined variable ' + args[i].name);
                        return;
                    }
                    
                    args[i] = value;
                }
            }
            
            // Call the function
            var ret = fn.exec.apply(null, args);
            
            // Place the return value on the stack if one is provided
            if (ret !== undefined)
            {
                layer.stack.push(ret);
            }
        }
    })();
    
    this.word_layer.next_layer = this.exec_layer;
}
